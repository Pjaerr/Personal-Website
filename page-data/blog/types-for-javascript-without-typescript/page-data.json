{"componentChunkName":"component---src-templates-blog-post-template-js","path":"/blog/types-for-javascript-without-typescript","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"isHidden\": false,\n  \"path\": \"/blog/types-for-javascript-without-typescript\",\n  \"date\": \"2020-08-23\",\n  \"title\": \"Types for JavaScript without TypeScript\",\n  \"description\": \"How to have types in JavaScript without TypeScript by using JSDOC comments - defining typedefs in a separate file and using them throughout your codebase.\",\n  \"issueLink\": \"Pjaerr/Personal-Website/issues/9\",\n  \"image\": \"/types-for-javascript-without-typescript/cover_image.jpg\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The other day I was working on a side project and I wanted a way to define the properties an object being passed into a function was supposed to have so that I could get good intellisense when working within the function.\"), mdx(\"p\", null, \"I instinctively thought of using TypeScript, afterall isn't needing types a good reason to use TypeScript?\"), mdx(\"p\", null, \"After much deliberation \", mdx(\"small\", null, \"(5 minutes of thinking about it)\"), \" I decided TypeScript was a bit overkill and went with simple JSDOC comments.\"), mdx(\"p\", null, \"JSDOC comments are great, you put a simple comment above whatever it is you're typing and you'll magically get intellisense, it also documents whatever you've typed too!\"), mdx(\"p\", null, \"As an example, let's say we have a function that takes a list of \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"tasks\"), \". Here's how you could type it using JSDOC comments:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"javascript\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token comment\"\n  }), \"/** @typedef {{\\n *  id: number,\\n *  name: string,\\n *  due: { date: (string | null), time: (string | null) },\\n *  isRepeating: boolean,\\n *  subTasks: Task[]\\n * }} Task */\"), \"\\n\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token comment\"\n  }), \"/**\\n * Takes a list of tasks and does something with them\\n * @param {Task[]} tasks\\n */\"), \"\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"function\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token function\"\n  }), \"exampleFunction\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token parameter\"\n  }), \"tasks\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"{\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"}\")))), mdx(\"p\", null, \"We've defined the type \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"Task\"), \" as being an object with all of those properties. The function has a simple comment above it telling it that the parameter \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"tasks\"), \" has a type of \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"Task[]\"), \", meaning an array of \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"Task\"), \" objects.\"), mdx(\"p\", null, \"Atleast when using VSCode, when we use \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"tasks\"), \" inside that function, it will give us proper intellisense. These kind of comments also work outside of vanilla JavaScript, I've used them in both Svelte and React projects without any issues.\"), mdx(\"h2\", null, \"Using JSDoc @typedef comments from one file in another file\"), mdx(\"p\", null, \"So this works, but what happens if we wanted to use this \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"Task\"), \" type somewhere else in the codebase? Right now we'd have to copy and paste the \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"@typedef\"), \" comment wherever we want to use it as our editor only knows about what it can see.\"), mdx(\"p\", null, \"Fortunately this is quite easy to solve, we can do this by putting our typedefs in a folder (either in separate js files or in a single js file) and then, at the root of our project, create a \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"jsconfig.json\"), \" file that points our editor to those files.\"), mdx(\"p\", null, \"So assuming we have the following file:\"), mdx(\"div\", {\n    \"className\": \"gatsby-code-title\"\n  }, \"src/types.js\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"javascript\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token comment\"\n  }), \"/** @typedef {{\\n *  id: number,\\n *  name: string,\\n *  due: { date: (string | null), time: (string | null) },\\n *  isRepeating: boolean,\\n *  subTasks: Task[]\\n * }} Task */\")))), mdx(\"p\", null, \"we would create a \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"jsconfig.json\"), \" file in the root of the project that looks like the following:\"), mdx(\"div\", {\n    \"className\": \"gatsby-code-title\"\n  }, \"jsconfig.json\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"json\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-json\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"{\"), \"\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token property\"\n  }), \"\\\"include\\\"\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token operator\"\n  }), \":\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"[\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token string\"\n  }), \"\\\"src/types.js\\\"\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"]\"), \"\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"}\")))), mdx(\"p\", null, \"If you had your types in separate files, you could put them in a folder and, in the jsconfig.json file reference like: \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"src/types/*.js\")), mdx(\"p\", null, \"Now we can use these types anywhere in our codebase just like we did in the example above, except we don't need to define the type in the same file:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"javascript\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token comment\"\n  }), \"/**\\n * Takes a list of tasks and does something with them\\n * @param {Task[]} tasks\\n */\"), \"\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"function\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token function\"\n  }), \"exampleFunction\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token parameter\"\n  }), \"tasks\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"{\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"}\")))), mdx(\"p\", null, \"and that's essentially it! I could have used TypeScript, but for something so simple TypeScript seemed overkill.\"), mdx(\"p\", null, \"You can do so much more with JSDOC comments than what I've shown here, for more information their \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://jsdoc.app/\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow\"\n  }), \"documentation\"), \" is great.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"date":"August 23, 2020","path":"/blog/types-for-javascript-without-typescript","title":"Types for JavaScript without TypeScript","description":"How to have types in JavaScript without TypeScript by using JSDOC comments - defining typedefs in a separate file and using them throughout your codebase.","issueLink":"Pjaerr/Personal-Website/issues/9","image":"/types-for-javascript-without-typescript/cover_image.jpg"}}},"pageContext":{}}}